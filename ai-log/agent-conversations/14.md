# A quick unstructured venture
While recording a demo video i've noticed that loopcuts are perfect on the first cut but completely messed up on subsequent cuts. I don't think it required a sophisticated prompt for this, so i just wrote a simple natural language one (while also asking it to refactor it into a dedicated file)

## Prompt
Offload the whole loopcutting thing in separate files and hooks. It is doing everything inside editmode overlay bloating the file completely

Also there is a bug it is showing perfect cuts but i assume it is on the data layer cutting incorrectly since followup cuts are messed up after the first one happened

## Result
Unfortunately none of the models were capable of fixing the issue inside VSCode. The refactoring was sucessful, however the cuts were still wrong.

So i gave grok 4 the code and asked it to think deeply about the problem and figure out a solution. It correctly identified that the canonpoint and getOrCreateEdge functions were miscalculating things and after one bad fix it followed up with the perfect implementation.

Final Answer from Grok:
To address the issue where cuts (both initial and subsequent) are now appearing diagonal or zigzag due to inconsistent edge orientations, we need to refine the canonicalization logic further. The previous suggestion oriented edges based on y-coordinates but still allowed ID-based swaps to affect the interpolation direction, leading to mismatched parameterization across spans. Additionally, it didn't handle cases where y-coordinates are equal (e.g., horizontal edges).
The core problem remains inconsistent directions: when connecting points at the same t across spans, if the underlying edge orientations differ (due to face winding or vertex ordering), the effective positions don't align geometrically, resulting in diagonals instead of straight cuts.
To fix this robustly:

For both preview (canonPoint) and application (getOrCreateOnEdge), determine the "low" to "high" direction based on the dominant axis of the edge (the one with the largest position delta). This orients from the smaller to larger value on that axis, ensuring consistency regardless of local edge order or vertex IDs.
Fall back to vertex ID sorting only if positions are equal on the dominant axis (rare).
Compute positions (and interpolate normals/UVs) always from low to high at the input t, making t represent the same relative position along the edge's natural direction.
For the creation key in edgeSplit, use ID-sorted undirected edge to ensure sharing, but keep computation independent of IDs.

This ensures straight, connected cuts for any edge orientation (vertical, horizontal, etc.) on meshes like cubes.
Update canonPoint in useLoopcut as follows:
typescriptconst canonPoint = (edge: [string, string], t: number) => {
  const va = vmapLocal.get(edge[0])!;
  const vb = vmapLocal.get(edge[1])!;
  const da = va.position;
  const db = vb.position;

  // Find dominant axis
  const dx = Math.abs(da.x - db.x);
  const dy = Math.abs(da.y - db.y);
  const dz = Math.abs(da.z - db.z);
  const maxD = Math.max(dx, dy, dz);
  let axis: 'x' | 'y' | 'z' = 'y';
  if (maxD === dx) axis = 'x';
  else if (maxD === dz) axis = 'z';

  // Determine low and high based on axis
  let low = va;
  let high = vb;
  if (da[axis] > db[axis]) {
    low = vb;
    high = va;
  }

  // Fallback if equal on axis
  if (da[axis] === db[axis]) {
    const minId = edge[0] < edge[1] ? edge[0] : edge[1];
    const maxId = edge[0] < edge[1] ? edge[1] : edge[0];
    low = vmapLocal.get(minId)!;
    high = vmapLocal.get(maxId)!;
  }

  // Compute point at t from low to high
  const p = {
    x: low.position.x + t * (high.position.x - low.position.x),
    y: low.position.y + t * (high.position.y - low.position.y),
    z: low.position.z + t * (high.position.z - low.position.z),
  };
  return new Vector3(p.x, p.y, p.z);
};
Update getOrCreateOnEdge in applyLoopCut as follows (also interpolating normals and UVs for consistency, as copying from one endpoint was arbitrary):
typescriptconst getOrCreateOnEdge = (edge: [string, string], t: number, segIndex: number) => {
  const va = vmap.get(edge[0])!;
  const vb = vmap.get(edge[1])!;
  const da = va.position;
  const db = vb.position;

  // Find dominant axis
  const dx = Math.abs(da.x - db.x);
  const dy = Math.abs(da.y - db.y);
  const dz = Math.abs(da.z - db.z);
  const maxD = Math.max(dx, dy, dz);
  let axis: 'x' | 'y' | 'z' = 'y';
  if (maxD === dx) axis = 'x';
  else if (maxD === dz) axis = 'z';

  // Determine low and high based on axis
  let low = va;
  let high = vb;
  if (da[axis] > db[axis]) {
    low = vb;
    high = va;
  }

  // Fallback if equal on axis
  if (da[axis] === db[axis]) {
    const minId = edge[0] < edge[1] ? edge[0] : edge[1];
    const maxId = edge[0] < edge[1] ? edge[1] : edge[0];
    low = vmap.get(minId)!;
    high = vmap.get(maxId)!;
  }

  // Canonical key (undirected, ID-sorted)
  let a = edge[0], b = edge[1];
  if (a > b) { const tmp = a; a = b; b = tmp; }
  const k = `${a}-${b}|${segIndex}`;

  const found = edgeSplit.get(k);
  if (found) return found;

  // Compute pos at t from low to high
  const pos = {
    x: low.position.x + t * (high.position.x - low.position.x),
    y: low.position.y + t * (high.position.y - low.position.y),
    z: low.position.z + t * (high.position.z - low.position.z),
  };

  // Interpolate normal and uv
  const normal = {
    x: low.normal.x + t * (high.normal.x - low.normal.x),
    y: low.normal.y + t * (high.normal.y - low.normal.y),
    z: low.normal.z + t * (high.normal.z - low.normal.z),
  };
  const uv = {
    u: low.uv.u + t * (high.uv.u - low.uv.u),
    v: low.uv.v + t * (high.uv.v - low.uv.v),
  };

  const dup = createVertex(pos, normal, uv);
  m.vertices.push(dup);
  vmap.set(dup.id, dup);
  edgeSplit.set(k, dup.id);
  return dup.id;
};
This should resolve the diagonal/zigzag issues for all cuts on a cube or similar meshes. Test by applying initial horizontal/vertical cuts, then subsequent onesâ€”the previews and results should now be straight and connected. If your meshes have edges with near-zero deltas on all axes (degenerate), add epsilon checks. If the dominant axis choice doesn't align with expected cut directions in non-axis-aligned meshes, you could project onto the face normal for orientation, but this is sufficient for standard cases.